//
// Copyright(C) Advanced Micro Devices, Inc. All rights reserved.
//
// You may not use this software and documentation (if any) (collectively,
// the "Materials") except in compliance with the terms and conditions of
// the Software License Agreement included with the Materials or otherwise as
// set forth in writing and signed by you and an authorized signatory of AMD.
// If you do not have a copy of the Software License Agreement, contact your
// AMD representative for a copy.
//
// You agree that you will not reverse engineer or decompile the Materials,
// in whole or in part, except as allowed by applicable law.
//
// THE MATERIALS ARE DISTRIBUTED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
// REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
//
//----------------------------------------------------------------------------
///
/// \file
/// GPU object protobuf APIs
///
//----------------------------------------------------------------------------

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: gpu.proto

/*
Copyright (c) Advanced Micro Devices, Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package amdgpu

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GPUSvc_GPUGet_FullMethodName                 = "/amdgpu.GPUSvc/GPUGet"
	GPUSvc_GPUUpdate_FullMethodName              = "/amdgpu.GPUSvc/GPUUpdate"
	GPUSvc_GPUComputePartitionSet_FullMethodName = "/amdgpu.GPUSvc/GPUComputePartitionSet"
	GPUSvc_GPUComputePartitionGet_FullMethodName = "/amdgpu.GPUSvc/GPUComputePartitionGet"
	GPUSvc_GPUMemoryPartitionSet_FullMethodName  = "/amdgpu.GPUSvc/GPUMemoryPartitionSet"
	GPUSvc_GPUMemoryPartitionGet_FullMethodName  = "/amdgpu.GPUSvc/GPUMemoryPartitionGet"
	GPUSvc_GPUReset_FullMethodName               = "/amdgpu.GPUSvc/GPUReset"
)

// GPUSvcClient is the client API for GPUSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// gRPC APIs to manage & monitor GPU resources on the compute node
type GPUSvcClient interface {
	// GPU get API
	GPUGet(ctx context.Context, in *GPUGetRequest, opts ...grpc.CallOption) (*GPUGetResponse, error)
	// GPU update API
	GPUUpdate(ctx context.Context, in *GPUUpdateRequest, opts ...grpc.CallOption) (*GPUUpdateResponse, error)
	// GPU partition create/update API
	GPUComputePartitionSet(ctx context.Context, in *GPUComputePartitionSetRequest, opts ...grpc.CallOption) (*GPUComputePartitionSetResponse, error)
	// GPU partition get API
	GPUComputePartitionGet(ctx context.Context, in *GPUComputePartitionGetRequest, opts ...grpc.CallOption) (*GPUComputePartitionGetResponse, error)
	// GPU memory partition create/update API
	GPUMemoryPartitionSet(ctx context.Context, in *GPUMemoryPartitionSetRequest, opts ...grpc.CallOption) (*GPUMemoryPartitionSetResponse, error)
	// GPU memory partition get API
	GPUMemoryPartitionGet(ctx context.Context, in *GPUMemoryPartitionGetRequest, opts ...grpc.CallOption) (*GPUMemoryPartitionGetResponse, error)
	// operational APIs or tasks
	// GPU reset API
	GPUReset(ctx context.Context, in *GPUResetRequest, opts ...grpc.CallOption) (*GPUResetResponse, error)
}

type gPUSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewGPUSvcClient(cc grpc.ClientConnInterface) GPUSvcClient {
	return &gPUSvcClient{cc}
}

func (c *gPUSvcClient) GPUGet(ctx context.Context, in *GPUGetRequest, opts ...grpc.CallOption) (*GPUGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GPUGetResponse)
	err := c.cc.Invoke(ctx, GPUSvc_GPUGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gPUSvcClient) GPUUpdate(ctx context.Context, in *GPUUpdateRequest, opts ...grpc.CallOption) (*GPUUpdateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GPUUpdateResponse)
	err := c.cc.Invoke(ctx, GPUSvc_GPUUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gPUSvcClient) GPUComputePartitionSet(ctx context.Context, in *GPUComputePartitionSetRequest, opts ...grpc.CallOption) (*GPUComputePartitionSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GPUComputePartitionSetResponse)
	err := c.cc.Invoke(ctx, GPUSvc_GPUComputePartitionSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gPUSvcClient) GPUComputePartitionGet(ctx context.Context, in *GPUComputePartitionGetRequest, opts ...grpc.CallOption) (*GPUComputePartitionGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GPUComputePartitionGetResponse)
	err := c.cc.Invoke(ctx, GPUSvc_GPUComputePartitionGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gPUSvcClient) GPUMemoryPartitionSet(ctx context.Context, in *GPUMemoryPartitionSetRequest, opts ...grpc.CallOption) (*GPUMemoryPartitionSetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GPUMemoryPartitionSetResponse)
	err := c.cc.Invoke(ctx, GPUSvc_GPUMemoryPartitionSet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gPUSvcClient) GPUMemoryPartitionGet(ctx context.Context, in *GPUMemoryPartitionGetRequest, opts ...grpc.CallOption) (*GPUMemoryPartitionGetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GPUMemoryPartitionGetResponse)
	err := c.cc.Invoke(ctx, GPUSvc_GPUMemoryPartitionGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gPUSvcClient) GPUReset(ctx context.Context, in *GPUResetRequest, opts ...grpc.CallOption) (*GPUResetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GPUResetResponse)
	err := c.cc.Invoke(ctx, GPUSvc_GPUReset_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GPUSvcServer is the server API for GPUSvc service.
// All implementations must embed UnimplementedGPUSvcServer
// for forward compatibility.
//
// gRPC APIs to manage & monitor GPU resources on the compute node
type GPUSvcServer interface {
	// GPU get API
	GPUGet(context.Context, *GPUGetRequest) (*GPUGetResponse, error)
	// GPU update API
	GPUUpdate(context.Context, *GPUUpdateRequest) (*GPUUpdateResponse, error)
	// GPU partition create/update API
	GPUComputePartitionSet(context.Context, *GPUComputePartitionSetRequest) (*GPUComputePartitionSetResponse, error)
	// GPU partition get API
	GPUComputePartitionGet(context.Context, *GPUComputePartitionGetRequest) (*GPUComputePartitionGetResponse, error)
	// GPU memory partition create/update API
	GPUMemoryPartitionSet(context.Context, *GPUMemoryPartitionSetRequest) (*GPUMemoryPartitionSetResponse, error)
	// GPU memory partition get API
	GPUMemoryPartitionGet(context.Context, *GPUMemoryPartitionGetRequest) (*GPUMemoryPartitionGetResponse, error)
	// operational APIs or tasks
	// GPU reset API
	GPUReset(context.Context, *GPUResetRequest) (*GPUResetResponse, error)
	mustEmbedUnimplementedGPUSvcServer()
}

// UnimplementedGPUSvcServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGPUSvcServer struct{}

func (UnimplementedGPUSvcServer) GPUGet(context.Context, *GPUGetRequest) (*GPUGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPUGet not implemented")
}
func (UnimplementedGPUSvcServer) GPUUpdate(context.Context, *GPUUpdateRequest) (*GPUUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPUUpdate not implemented")
}
func (UnimplementedGPUSvcServer) GPUComputePartitionSet(context.Context, *GPUComputePartitionSetRequest) (*GPUComputePartitionSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPUComputePartitionSet not implemented")
}
func (UnimplementedGPUSvcServer) GPUComputePartitionGet(context.Context, *GPUComputePartitionGetRequest) (*GPUComputePartitionGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPUComputePartitionGet not implemented")
}
func (UnimplementedGPUSvcServer) GPUMemoryPartitionSet(context.Context, *GPUMemoryPartitionSetRequest) (*GPUMemoryPartitionSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPUMemoryPartitionSet not implemented")
}
func (UnimplementedGPUSvcServer) GPUMemoryPartitionGet(context.Context, *GPUMemoryPartitionGetRequest) (*GPUMemoryPartitionGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPUMemoryPartitionGet not implemented")
}
func (UnimplementedGPUSvcServer) GPUReset(context.Context, *GPUResetRequest) (*GPUResetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPUReset not implemented")
}
func (UnimplementedGPUSvcServer) mustEmbedUnimplementedGPUSvcServer() {}
func (UnimplementedGPUSvcServer) testEmbeddedByValue()                {}

// UnsafeGPUSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GPUSvcServer will
// result in compilation errors.
type UnsafeGPUSvcServer interface {
	mustEmbedUnimplementedGPUSvcServer()
}

func RegisterGPUSvcServer(s grpc.ServiceRegistrar, srv GPUSvcServer) {
	// If the following call pancis, it indicates UnimplementedGPUSvcServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GPUSvc_ServiceDesc, srv)
}

func _GPUSvc_GPUGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUSvcServer).GPUGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GPUSvc_GPUGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUSvcServer).GPUGet(ctx, req.(*GPUGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GPUSvc_GPUUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUSvcServer).GPUUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GPUSvc_GPUUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUSvcServer).GPUUpdate(ctx, req.(*GPUUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GPUSvc_GPUComputePartitionSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUComputePartitionSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUSvcServer).GPUComputePartitionSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GPUSvc_GPUComputePartitionSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUSvcServer).GPUComputePartitionSet(ctx, req.(*GPUComputePartitionSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GPUSvc_GPUComputePartitionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUComputePartitionGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUSvcServer).GPUComputePartitionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GPUSvc_GPUComputePartitionGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUSvcServer).GPUComputePartitionGet(ctx, req.(*GPUComputePartitionGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GPUSvc_GPUMemoryPartitionSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUMemoryPartitionSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUSvcServer).GPUMemoryPartitionSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GPUSvc_GPUMemoryPartitionSet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUSvcServer).GPUMemoryPartitionSet(ctx, req.(*GPUMemoryPartitionSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GPUSvc_GPUMemoryPartitionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUMemoryPartitionGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUSvcServer).GPUMemoryPartitionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GPUSvc_GPUMemoryPartitionGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUSvcServer).GPUMemoryPartitionGet(ctx, req.(*GPUMemoryPartitionGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GPUSvc_GPUReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPUResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GPUSvcServer).GPUReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GPUSvc_GPUReset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GPUSvcServer).GPUReset(ctx, req.(*GPUResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GPUSvc_ServiceDesc is the grpc.ServiceDesc for GPUSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GPUSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "amdgpu.GPUSvc",
	HandlerType: (*GPUSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GPUGet",
			Handler:    _GPUSvc_GPUGet_Handler,
		},
		{
			MethodName: "GPUUpdate",
			Handler:    _GPUSvc_GPUUpdate_Handler,
		},
		{
			MethodName: "GPUComputePartitionSet",
			Handler:    _GPUSvc_GPUComputePartitionSet_Handler,
		},
		{
			MethodName: "GPUComputePartitionGet",
			Handler:    _GPUSvc_GPUComputePartitionGet_Handler,
		},
		{
			MethodName: "GPUMemoryPartitionSet",
			Handler:    _GPUSvc_GPUMemoryPartitionSet_Handler,
		},
		{
			MethodName: "GPUMemoryPartitionGet",
			Handler:    _GPUSvc_GPUMemoryPartitionGet_Handler,
		},
		{
			MethodName: "GPUReset",
			Handler:    _GPUSvc_GPUReset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gpu.proto",
}

const (
	DebugGPUSvc_GPUBadPageGet_FullMethodName = "/amdgpu.DebugGPUSvc/GPUBadPageGet"
)

// DebugGPUSvcClient is the client API for DebugGPUSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// gRPC internal debug APIs to manage & monitor GPU resources
type DebugGPUSvcClient interface {
	// GPU get bad pages
	GPUBadPageGet(ctx context.Context, in *GPUBadPageGetRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GPUBadPageGetResponse], error)
}

type debugGPUSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewDebugGPUSvcClient(cc grpc.ClientConnInterface) DebugGPUSvcClient {
	return &debugGPUSvcClient{cc}
}

func (c *debugGPUSvcClient) GPUBadPageGet(ctx context.Context, in *GPUBadPageGetRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[GPUBadPageGetResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DebugGPUSvc_ServiceDesc.Streams[0], DebugGPUSvc_GPUBadPageGet_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GPUBadPageGetRequest, GPUBadPageGetResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DebugGPUSvc_GPUBadPageGetClient = grpc.ServerStreamingClient[GPUBadPageGetResponse]

// DebugGPUSvcServer is the server API for DebugGPUSvc service.
// All implementations must embed UnimplementedDebugGPUSvcServer
// for forward compatibility.
//
// gRPC internal debug APIs to manage & monitor GPU resources
type DebugGPUSvcServer interface {
	// GPU get bad pages
	GPUBadPageGet(*GPUBadPageGetRequest, grpc.ServerStreamingServer[GPUBadPageGetResponse]) error
	mustEmbedUnimplementedDebugGPUSvcServer()
}

// UnimplementedDebugGPUSvcServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDebugGPUSvcServer struct{}

func (UnimplementedDebugGPUSvcServer) GPUBadPageGet(*GPUBadPageGetRequest, grpc.ServerStreamingServer[GPUBadPageGetResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GPUBadPageGet not implemented")
}
func (UnimplementedDebugGPUSvcServer) mustEmbedUnimplementedDebugGPUSvcServer() {}
func (UnimplementedDebugGPUSvcServer) testEmbeddedByValue()                     {}

// UnsafeDebugGPUSvcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DebugGPUSvcServer will
// result in compilation errors.
type UnsafeDebugGPUSvcServer interface {
	mustEmbedUnimplementedDebugGPUSvcServer()
}

func RegisterDebugGPUSvcServer(s grpc.ServiceRegistrar, srv DebugGPUSvcServer) {
	// If the following call pancis, it indicates UnimplementedDebugGPUSvcServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DebugGPUSvc_ServiceDesc, srv)
}

func _DebugGPUSvc_GPUBadPageGet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GPUBadPageGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DebugGPUSvcServer).GPUBadPageGet(m, &grpc.GenericServerStream[GPUBadPageGetRequest, GPUBadPageGetResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DebugGPUSvc_GPUBadPageGetServer = grpc.ServerStreamingServer[GPUBadPageGetResponse]

// DebugGPUSvc_ServiceDesc is the grpc.ServiceDesc for DebugGPUSvc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DebugGPUSvc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "amdgpu.DebugGPUSvc",
	HandlerType: (*DebugGPUSvcServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GPUBadPageGet",
			Handler:       _DebugGPUSvc_GPUBadPageGet_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "gpu.proto",
}
